<!DOCTYPE html> 
<html>
<head>
    <meta charset="UTF-8">
    <title>Newton Fractal</title>
</head>
<body>
    <canvas id="canvas" width=800, height=800></canvas>
    
    <div style="position:absolute; left:830px; top:10px;">
        <table id="params">
            <tr>
                <td>Iteration Steps</td>
                <td><input id="steps-input" value="15" onchange="compile();draw()"/></td>
            </tr>
            <tr>
                <td>Supersampling</td>
                <td>
                    <select id="supersampling" onchange="compile();draw()">
                        <option value="1">off</option>
                        <option value="2"> x2</option>
                        <option value="4"> x4</option>
                        <option value="8"> x8</option>
                    </select>
                </td>
            </tr>
            <tr>
                <td>Points</td>
                <td id = "colors"></td>
            </tr>
        </table>
        <button onclick="points.push();compile();draw()">+</button>
        <button onclick="points.pop();compile();draw()">-</button>
        
        <h3>Notes</h3>
        <ul>
            <li>You can drag the points with your mouse.</li>
            <li>Mobile browsers are not supported yet.</li>
        </ul>
    </div>
    
    <script type="text/javascript" src="glutils.js"></script>
    <script type="text/javascript">
        var canvas = document.getElementById("canvas");
        var gl = canvas.getContext("experimental-webgl");

        // Scale from coord to complex number to avoid float overflow when there are too many points.
        const kComplexToCoord = Math.min(canvas.width, canvas.height);
        const kCoordToComplex = 1.0 / kComplexToCoord;

        var colorsContainer = document.getElementById("colors");
        var points =  {
            positions : [],

            length() {
                return this.positions.length;
            },

            closestIndex(position) {
                let closest_index = 0;
                let min_distance = Infinity;
                for (let i = 0; i < this.length(); ++i) {
                    let dx = position[0] - this.positions[i][0];
                    let dy = position[1] - this.positions[i][1];
                    const this_distance_square = dx * dx + dy * dy;
                    if (this_distance_square < min_distance) {
                        closest_index = i;
                        min_distance = this_distance_square;
                    }
                }
                return closest_index
            },

            setPosition(index, position) {
                this.positions[index] = position;
            },

            positionsArray() {
                let res = new Float32Array(this.length() * 2);
                for (let i = 0; i < this.length(); ++i) {
                    res[i * 2 + 0] = this.positions[i][0] * kCoordToComplex;
                    res[i * 2 + 1] = this.positions[i][1] * kCoordToComplex;
                }
                return res;
            },

            colorsArray() {
                let res = new Float32Array(this.length() * 3);
                for (let i = 0; i < this.length(); ++i) {
                    let color_str = document.getElementById(`colors${i}`).value;
                    res[i * 3 + 0] = parseInt(color_str.substring(1, 3), 16) / 255.0;
                    res[i * 3 + 1] = parseInt(color_str.substring(3, 5), 16) / 255.0;
                    res[i * 3 + 2] = parseInt(color_str.substring(5, 7), 16) / 255.0;
                }
                return res;
            },

            push() {
                this.positions.push([Math.random() * (canvas.width - 1), Math.random() * (canvas.height - 1)]);
                
                let input = document.createElement("input");
                input.type = "color";
                input.id = `colors${this.length() - 1}`;
                const digits = '0123456789ABCDEF';
                let color = '#';
                for (let i = 0; i < 6; ++i) {
                    color += digits[Math.floor(Math.random() * digits.length)];
                }
                input.value = color;
                input.addEventListener('change', (e) => {draw();});
                colorsContainer.appendChild(input);
            },

            pop() {
                if (this.length() > 2) {
                    this.positions.pop();
                    colorsContainer.removeChild(colorsContainer.lastChild);
                }
            }
        }

        points.push();
        points.push();
        points.push();
        points.push();
    
        var uniforms;
        
        function compile() {
            const vertex_shader = `
            attribute vec2 aPosition;
            void main() {
                gl_Position = vec4(aPosition, 0, 1);
            }
            `;
            
            const kNumSteps = parseInt(document.getElementById("steps-input").value);
            const kNumRoots = points.length();

            function generateArgs(length) {
                let res = '';
                for (let i = 0; i < length; ++i) {
                    res += `, vec2 p${i}`;
                }
                return res;
            }

            function generateCallArgs(length, excluded) {
                let res = '';
                for (let i = 0; i < length; ++i) {
                    if (i != excluded) {
                        res += `, p${i}`;
                    }
                }
                return res;
            }

            function generateF(i) {
                if (i == 1) {
                    return `
                    vec2 F1(vec2 x, vec2 p0) {
                        return x - p0;
                    }
                    `;
                } else {
                    return generateF(i - 1) + `
                    vec2 F${i}(vec2 x ${generateArgs(i)}) {
                        return Mul(F1(x, p0), F${i - 1}(x ${generateCallArgs(i, 0)}));
                    }
                    `;
                }
            }

            function generateDfdx(i) {
                if (i == 1) {
                    return `
                    vec2 Dfdx1(vec2 x, vec2 p0) {
                        return 1;
                    }
                    `;
                } else {
                    let adds = '';
                    for (let j = 0; j < i; ++j) {
                        adds += `+ F${i - 1}(x${generateCallArgs(i, j)})`;
                    }
                    return `
                    vec2 Dfdx${i}(vec2 x${generateArgs(i)}) {
                        return ${adds};
                    }
                    `;
                }
            }

            function generateUniformArgs(i) {
                let args = '';
                for (let j = 0; j < i; ++j) {
                    args += `, roots[${j}]`;
                }
                return args;
            }

            const uniformArgs = generateUniformArgs(kNumRoots);
            
            const fragment_shader = `
            precision mediump float;

            const int kSteps = ${kNumSteps};
            const int kNumRoots = ${kNumRoots};
            uniform vec2 roots[kNumRoots];
            uniform vec3 colors[kNumRoots];

            vec2 Mul(vec2 a, vec2 b) {
                return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
            }

            vec2 Div(vec2 a, vec2 b) {
                return vec2(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y) / (b.x * b.x + b.y * b.y);
            }

            ${generateF(kNumRoots)}
            ${generateDfdx(kNumRoots)}

            vec2 Step(vec2 x) {
                return -Div(F${kNumRoots}(x${uniformArgs}), Dfdx${kNumRoots}(x${uniformArgs}));
            }

            vec4 Sample(vec2 coord) {
                vec4 res = vec4(0);

                vec2 x = coord * ${kCoordToComplex};
                for (int i = 0; i < kSteps; ++i) {
                    x += Step(x);
                }

                float distances[kNumRoots];
                for (int i = 0; i < kNumRoots; ++i) {
                    distances[i] = length(x - roots[i]);
                }

                float min_distance = 1.0 / 0.0;
                for (int i = 0; i < kNumRoots; ++i) {
                    min_distance = min(min_distance, distances[i]);
                }

                for (int i = 0; i < kNumRoots; ++i) {
                    if (distances[i] == min_distance) {
                        res = vec4(colors[i], 1.0);
                        break;
                    }
                }

                for (int i = 0; i < kNumRoots; ++i) {
                    float pixel_distance = length(coord - roots[i] * float(${kComplexToCoord}));
                    if (pixel_distance >= 3.5 && pixel_distance <= 6.5) {
                        res = vec4(fract(colors[i] + vec3(0.5, 0.5, 0.5)), 1.0);
                    }
                }

                return res;
            }

            void main() {
            #define NUM_SAMPLES ${document.getElementById("supersampling").value}
            #if NUM_SAMPLES == 8
                vec2 biases[NUM_SAMPLES];
                biases[0] = vec2(-7.0 / 16.0,  1.0 / 16.0);
                biases[1] = vec2(-3.0 / 16.0,  5.0 / 16.0);
                biases[2] = vec2( 1.0 / 16.0,  3.0 / 16.0);
                biases[3] = vec2( 7.0 / 16.0,  7.0 / 16.0);
                biases[4] = vec2( 5.0 / 16.0, -1.0 / 16.0);
                biases[5] = vec2( 3.0 / 16.0, -7.0 / 16.0);
                biases[6] = vec2(-1.0 / 16.0, -3.0 / 16.0);
                biases[7] = vec2(-5.0 / 16.0, -5.0 / 16.0);
            #elif NUM_SAMPLES == 4
                vec2 biases[NUM_SAMPLES];
                biases[0] = vec2(-1.0 / 8.0,  3.0 / 4.0);
                biases[1] = vec2( 3.0 / 8.0,  1.0 / 8.0);
                biases[2] = vec2( 1.0 / 8.0, -3.0 / 8.0);
                biases[3] = vec2(-3.0 / 8.0, -1.0 / 8.0);
            #elif NUM_SAMPLES == 2
                vec2 biases[NUM_SAMPLES];
                biases[0] = vec2(-1.0 / 4.0,  1.0 / 4.0);
                biases[1] = vec2( 1.0 / 4.0, -1.0 / 4.0);
            #else
                vec2 biases[NUM_SAMPLES];
                biases[0] = vec2(0, 0);
            #endif

                vec4 sum = vec4(0);
                for (int i = 0; i < NUM_SAMPLES; ++i) {
                    sum += Sample(gl_FragCoord.xy + biases[i]);
                }
                gl_FragColor = sum * (1.0 / float(NUM_SAMPLES));
            }
            `;

            const program = createProgram(vertex_shader, fragment_shader);
            gl.useProgram(program);
            uniforms = {
                roots : gl.getUniformLocation(program,'roots'),
                colors : gl.getUniformLocation(program, 'colors'),
            };
        }

        function draw() {
            gl.uniform2fv(uniforms.roots, points.positionsArray());
            gl.uniform3fv(uniforms.colors, points.colorsArray());
            gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
        }
        
        function getPosition(e) {
            return [e.offsetX, canvas.height - 1 - e.offsetY];
        }

        var index = -1;
        
        function distance(p1, p2) {
            const dx = p1[0] - p2[0];
            const dy = p1[1] - p2[1];
            return Math.sqrt(dx * dx, dy * dy);
        }

        canvas.addEventListener("mousedown", e => {
            const click_position = getPosition(e);
            index = points.closestIndex(click_position);
        });
        canvas.addEventListener("mousemove", e => {
            if (index != -1) {
                const click_position = getPosition(e);
                points.setPosition(index, click_position);
                draw();
            }
        });
        canvas.addEventListener("mouseup", e => {
            index = -1;
        });

        var buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 8, 0);
        array = new Float32Array([
            -1, -1,
            -1, +1,
            +1, +1,
            +1, -1
        ]);
        gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);
        
        compile();
        draw();
    </script>
</body>
</html>